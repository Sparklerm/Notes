# 8种基本数据类型

Java中有8种基本数据类型分为三大类。

### 字符型

> char

### 布尔型

> boolean

### 数值型

> 1.整型：byte、short、int、long
>
> 2.浮点型：float、double

*String不是基本数据类型，是引用类型。*

# 整型中byte、short、int、long的取值范围

Java中的整型主要包含byte、short、int和long这四种，表示的数字范围也是从小到大的，之所以表示范围不同主要和他们存储数据时所占的字节数有关。

先来个简单的科普，`1字节(byte)=8位(bit)`。java中的整型属于有符号数。

先来看计算中8bit可以表示的数字： 最小值：10000000 （-128）(-2^7) 最大值：01111111（127）(2^7-1) 具体计算方式参考：[Java中，为什么byte类型的取值范围为-128~127? - CSDN博客](https://blog.csdn.net/qq_23418393/article/details/57421688)

整型的这几个类型中，

|  类型   | 内存占用 | 取值范围                                                     | 默认值  |
| :-----: | :------: | :----------------------------------------------------------- | :-----: |
| `byte`  |   8bit   | `-128(-2^7)到127(2^7-1)`                                     |    0    |
| `short` |  2byte   | `-32,768 (-2^15)到32,767 (2^15-1)`                           |    0    |
|  `int`  |  4byte   | `-2,147,483,648 (-2^31)到2,147,483,647 (2^31-1)`             |    0    |
| `long`  |  8byte   | `-9,223,372,036,854,775,808 (-2^63)到9,223,372,036, 854,775,807 (2^63-1)` | 0/0l/0L |

整型中，每个类型都有一定的表示范围，但是，在程序中有些计算会导致超出表示范围，即溢出。如以下代码：

```java
int i = Integer.MAX_VALUE;
int j = Integer.MAX_VALUE;

int k = i + j;
System.out.println("i (" + i + ") + j (" + j + ") = k (" + k + ")");
```

输出结果：`i (2147483647) + j (2147483647) = k (-2)`

这就是发生了溢出，溢出的时候并不会抛异常，也没有任何提示。所以，在程序中，使用同类型的数据进行运算的时候，一定要注意数据溢出的问题。

# 什么是浮点型？

我们知道，计算机的数字的存储和运算都是通过二进制进行的，对于，十进制整数转换为二进制整数采用"除2取余，逆序排列"法

具体做法是：

- 用2整除十进制整数，可以得到一个商和余数；
- 再用2去除商，又会得到一个商和余数，如此进行，直到商为小于1时为止

- 然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。

如，我们想要把127转换成二进制，做法如下：

![img](./assets/%E3%80%90Java%E3%80%9102%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/1640316778741-9aa4a1d3-e4a9-41e1-8754-786510a864d4.png)

那么，十进制小数转换成二进制小数，又该如何计算呢？

十进制小数转换成二进制小数采用"乘2取整，顺序排列"法。

具体做法是：

- 用2乘十进制小数，可以得到积
- 将积的整数部分取出，再用2乘余下的小数部分，又得到一个积

- 再将积的整数部分取出，如此进行，直到积中的小数部分为零，此时0或1为二进制的最后一位。或者达到所要求的精度为止。

如尝试将0.625转成二进制：

![img](./assets/%E3%80%90Java%E3%80%9102%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/1640316778560-df9caa9a-3a3a-4b68-a21e-857ac4dd967d.png)

但是0.625是一个特列，用同样的算法，请计算下0.1对应的二进制是多少：

![img](./assets/%E3%80%90Java%E3%80%9102%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/1640316778819-88c39984-7ce1-4b58-9f92-39ac33a1006d.png)

我们发现，0.1的二进制表示中出现了无限循环的情况，也就是(0.1)10 = (0.000110011001100…)2

这种情况，计算机就没办法用二进制精确的表示0.1了。

所以，为了解决部分小数无法使用二进制精确表示的问题，于是就有了IEEE 754规范。

IEEE二进制浮点数算术标准（IEEE 754）是20世纪80年代以来最广泛使用的浮点数运算标准，为许多CPU与浮点运算器所采用。

> **浮点数和小数并不是完全一样的，计算机中小数的表示法，其实有定点和浮点两种。因为在位数相同的情况下，定点数的表示范围要比浮点数小。所以在计算机科学中，使用浮点数来表示实数的近似值。**

IEEE 754规定了四种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、延伸单精确度（43比特以上，很少使用）与延伸双精确度（79比特以上，通常以80位实现）。

其中最常用的就是32位单精度浮点数和64位双精度浮点数。

IEEE并没有解决小数无法精确表示的问题，只是提出了一种使用近似值表示小数的方式，并且引入了精度的概念。

一个浮点数a由两个数m和e来表示：a = m × b^e。

在任意一个这样的系统中，我们选择一个基数b（记数系统的基）和精度p（即使用多少位来存储）。m（即尾数）是形如±d.ddd...ddd的p位数（每一位是一个介于0到b-1之间的整数，包括0和b-1)。

如果m的第一位是非0整数,m称作规格化的。有一些描述使用一个单独的符号位(s 代表+或者-）来表示正负，这样m必须是正的。e是指数。



# 什么是单精度和双精度？

单精度浮点数在计算机存储器中占用4个字节（32 bits），利用“浮点”（浮动小数点）的方法，可以表示一个范围很大的数值。

比起单精度浮点数，双精度浮点数(double)使用 64 位（8字节） 来存储一个浮点数。



# 为什么不能用浮点型表示金额？

由于计算机中保存的小数其实是十进制的小数的近似值，并不是准确值，所以，千万不要在代码中使用浮点数来表示金额等重要的指标。

建议使用BigDecimal或者Long（单位为分）来表示金额。