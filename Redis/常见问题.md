# Redis

## Redis的缓存穿透和缓存雪崩

### 缓存穿透

**如果在请求数据时，在缓存层和数据库层都没有找到符合条件的数据，也就是说，在缓存层和数据库层都没有命中数据，那么，这种情况就叫作缓存穿透**。

*解决方案：*使用分布式锁，保证对于每个Key同时只有一个线程去查询后端的服务，某个线程在查询后端服务的同时，其他线程没有获得分布式锁的权限，需要进行等待。

### 缓存雪崩

**在某一时刻缓存集中失效，或者缓存系统出现故障，所有的并发流量就会直接到达数据库。数据存储层的调用量就会暴增，导致数据库压力暴增，这种级联式的服务故障，就叫作缓存雪崩。**

*解决方案：*通过给Key过期时间添加一定的随机值，分散Key的过期时间，避免在短时间内出现大量热点数据过期的情况

## Redis Key删除策略

### 过期删除策略

- 定时检查删除：对于每一个设置了过期时间的 key 都会创建一个定时器，一旦达到过期时间都会删除。这种方式立即清除过期数据，对内存比较好，但是有缺点是：占用了大量 CPU 的资源去处理过期数据，会影响 redis 的吞吐量 和 响应时间。
- 惰性检查策略：当访问一个 key 的时候，才会判断该 key 是否过期，如果过期就删除。该方式能最大限度节省 CPU 的资源。但是对内存不太好，有一种比较极端的情况：出现大量的过期 key 没有被再次访问，因为不会被清除，导致占用了大量的内存。
- 定期检查删除：每隔一段时间，扫描redis 中过期key 的字典，并清除部分过期的key。这种方式是前俩种一种折中方法。不同的情况下，调整定时扫描时间间隔，让CPU 与 内存达到最优。

### 内存淘汰策略

> redis 内存淘汰策略是指达到maxmemory极限时，使用某种算法来决定来清理哪些数据，以保证新数据存入。

- 默认配置：不处理等待报错

  > - noeviction，发现内存不够时，不删除key，执行写入命令时直接返回错误信息。（Redis默认的配置就是noeviction）

- 从所有结果集中的Key中挑选，进行淘汰：

  - allkeys-random 就是从所有的key中随机挑选key，进行淘汰
  - allkeys-lru 就是从所有的key中挑选最近使用时间距离现在最远的key，进行淘汰
  - allkeys-lfu 就是从所有的key中挑选使用频率最低的key，进行淘汰。（这是Redis 4.0版本后新增的策略）

- 从设置了过期时间的Key中进行淘汰：

  - volatile-random 从设置了过期时间的结果集中随机挑选key删除。
  - volatile-lru 从设置了过期时间的结果集中挑选上次使用时间距离现在最久的key开始删除
  - volatile-ttl 从设置了过期时间的结果集中挑选可存活时间最短的key开始删除(也就是从哪些快要过期的key中先删除)
  - volatile-lfu 从过期时间的结果集中选择使用频率最低的key开始删除（这是Redis 4.0版本后新增的策略）

## Redis Key设置了过期时间后一定会被删除嘛？

redis的key到了过期时间后，**不会立刻被删除**，会通过redis 配置的删除策略来删除。

## 如何更新Redis Key

- 延迟双删：在更新DB数据前先删除缓存 --> 更新DB数据完成后 发送异步MQ删除指令 -->  删除Redis Key

  - 为什么要双删？：db更新分为两个阶段，更新前及更新后，更新前的删除很容易理解，在db更新的过程中由于读取的操作存在并发可能，会出现缓存重新写入数据，这时就需要更新后的删除。

  - 双删失败如何处理？

    1. 设置缓存过期时间
       从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。所有的写操作以数据库为准，只要到达缓存过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。结合双删策略+缓存超时设置，这样最差的情况就是在超时时间内数据存在不一致。

    2. 重试方案
       重试方案有两种实现，一种在业务层做，另外一种实现中间件负责处理。